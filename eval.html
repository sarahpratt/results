<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIAL-RL Evaluation</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Tab styles */
        .tab-container {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        .tab-button {
            padding: 12px 24px;
            border: none;
            background: #f5f5f5;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            border-radius: 8px 8px 0 0;
            margin-right: 4px;
            transition: all 0.2s;
        }
        .tab-button:hover {
            background: #e0e0e0;
        }
        .tab-button.active {
            background: white;
            color: #1976d2;
            border-bottom: 2px solid #1976d2;
            margin-bottom: -2px;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        /* Issues bar */
        .issues-bar {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
        }
        .issues-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            text-align: center;
        }
        .issues-bar-container {
            height: 24px;
            background: #e8f5e9;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .issues-bar-fill {
            height: 100%;
            background: linear-gradient(135deg, #ef9a9a 0%, #e57373 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }
        .issues-bar-label {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: #2e7d32;
            font-weight: 500;
        }
        /* Issues alert box */
        .issues-alert {
            background: #fff3e0;
            border: 1px solid #ffb74d;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 15px;
        }
        .issues-alert-title {
            font-weight: 600;
            color: #e65100;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .issues-alert-list {
            margin: 0;
            padding-left: 20px;
            color: #bf360c;
            font-size: 13px;
        }
        .issues-alert-list li {
            margin-bottom: 4px;
        }
        /* Triple heatmap container */
        .triple-heatmap {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .mini-heatmap {
            flex: 1;
            min-width: 280px;
            max-width: 400px;
        }
        .mini-heatmap-title {
            text-align: center;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Navigation -->
        <nav class="nav-bar">
            <a href="index.html" class="back-link">&#8592; Back to Model Comparison</a>
        </nav>

        <!-- Loading state -->
        <div id="loading" class="loading">
            <div class="loading-spinner"></div>
            <p>Loading evaluation data...</p>
        </div>

        <!-- Error state -->
        <div id="error" class="error" style="display: none;">
            <div class="error-icon">&#9888;</div>
            <p id="error-message">Failed to load evaluation data.</p>
        </div>

        <!-- Main content (hidden until loaded) -->
        <div id="main-content" style="display: none;">
            <!-- Header with model name and overall accuracy -->
            <div class="header">
                <div class="model-name" id="model-name"></div>
                <div class="accuracy-display">
                    <span class="accuracy-value" id="accuracy-value"></span>
                    <span class="accuracy-label">Overall Accuracy</span>
                </div>
                <div class="stats-row" id="stats-row"></div>
                <!-- Difficulty Calibration Stats -->
                <div class="difficulty-stats">
                    <div class="difficulty-title">Question Difficulty Distribution</div>
                    <div class="difficulty-bar" id="difficulty-bar"></div>
                    <div class="difficulty-legend" id="difficulty-legend"></div>
                </div>
                <!-- Issues bar -->
                <div class="issues-bar">
                    <div class="issues-title">Rollouts with Issues in Final Question</div>
                    <div class="issues-bar-container">
                        <div class="issues-bar-fill" id="issues-bar-fill"></div>
                        <span class="issues-bar-label" id="issues-bar-label"></span>
                    </div>
                </div>
            </div>

            <!-- Tabbed heatmap section -->
            <div class="heatmap-section">
                <div class="tab-container">
                    <button class="tab-button active" onclick="switchTab('accuracy')">Pairwise Accuracy</button>
                    <button class="tab-button" onclick="switchTab('difficulty')">Difficulty Breakdown</button>
                    <button class="tab-button" onclick="switchTab('issues')">Issues Matrix</button>
                </div>

                <div id="tab-accuracy" class="tab-content active">
                    <div class="heatmap-container">
                        <div id="heatmap-accuracy"></div>
                    </div>
                </div>

                <div id="tab-difficulty" class="tab-content">
                    <div class="triple-heatmap">
                        <div class="mini-heatmap">
                            <div class="mini-heatmap-title">Too Easy %</div>
                            <div id="heatmap-too-easy"></div>
                        </div>
                        <div class="mini-heatmap">
                            <div class="mini-heatmap-title">Calibrated %</div>
                            <div id="heatmap-calibrated"></div>
                        </div>
                        <div class="mini-heatmap">
                            <div class="mini-heatmap-title">Too Hard %</div>
                            <div id="heatmap-too-hard"></div>
                        </div>
                    </div>
                </div>

                <div id="tab-issues" class="tab-content">
                    <div class="heatmap-container">
                        <div id="heatmap-issues"></div>
                    </div>
                </div>
            </div>

            <!-- Conversation explorer -->
            <div class="explorer-section">
                <div class="section-title">Conversation Explorer</div>

                <div class="explorer-controls">
                    <div class="control-group">
                        <label class="control-label">Boundary Model A</label>
                        <select id="model-a-select"></select>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Boundary Model B</label>
                        <select id="model-b-select"></select>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Filter</label>
                        <select id="filter-select">
                            <option value="all">All Conversations</option>
                            <option value="issues">With Issues Only</option>
                        </select>
                    </div>
                    <div class="pair-accuracy">
                        <span>Pair Accuracy: </span>
                        <span class="pair-accuracy-value" id="pair-accuracy">--</span>
                        <span id="pair-stats"></span>
                    </div>
                </div>

                <div class="conv-nav">
                    <div class="conv-nav-buttons">
                        <button id="prev-btn" onclick="prevConversation()">&#8592; Previous</button>
                        <button id="next-btn" onclick="nextConversation()">Next &#8594;</button>
                    </div>
                    <div class="conv-counter">
                        Conversation <span id="conv-current">1</span> of <span id="conv-total">0</span>
                    </div>
                </div>

                <div id="conversation-display">
                    <div class="no-selection">
                        <div class="no-selection-icon">&#128172;</div>
                        <p>Select a model pair to view conversations</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get model name from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const modelName = urlParams.get('model');

        // Store loaded data
        let evalData = null;
        let currentConvIndex = 0;
        let currentConversations = [];
        let allConversationsForPair = [];
        let currentModelA = '';
        let currentModelB = '';
        let currentFilter = 'all';
        let currentTab = 'accuracy';

        // Precomputed pairwise stats
        let pairwiseStats = {};

        // Load data and initialize
        async function init() {
            if (!modelName) {
                showError('No model specified. Use ?model=model-name in the URL.');
                return;
            }

            try {
                const response = await fetch(`data/${modelName}.json`);
                if (!response.ok) {
                    throw new Error(`Could not load data for model: ${modelName}`);
                }
                evalData = await response.json();

                // Precompute pairwise statistics
                computePairwiseStats();

                document.title = `DIAL-RL Evaluation: ${evalData.metadata.questioner_model}`;
                renderPage();
            } catch (e) {
                showError(e.message);
            }
        }

        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
            document.getElementById('error-message').textContent = message;
        }

        function computePairwiseStats() {
            // Compute stats for each pair
            for (const [pairKey, convs] of Object.entries(evalData.conversations)) {
                let tooEasy = 0, calibrated = 0, tooHard = 0, withIssues = 0;

                convs.forEach(conv => {
                    if (conv.outcome === 'too_easy') tooEasy++;
                    else if (conv.outcome === 'calibrated') calibrated++;
                    else if (conv.outcome === 'too_hard') tooHard++;

                    // Check for issues in final turn
                    if (hasIssues(conv)) withIssues++;
                });

                const total = convs.length;
                pairwiseStats[pairKey] = {
                    total,
                    tooEasy,
                    calibrated,
                    tooHard,
                    withIssues,
                    tooEasyPct: total > 0 ? tooEasy / total : 0,
                    calibratedPct: total > 0 ? calibrated / total : 0,
                    tooHardPct: total > 0 ? tooHard / total : 0,
                    issuesPct: total > 0 ? withIssues / total : 0
                };
            }
        }

        function hasIssues(conv) {
            // Check conversation-level has_issue flag first
            if (conv.has_issue) return true;

            // Also check individual turn flags
            const finalTurn = (conv.turns || []).find(t => t.is_final);
            if (!finalTurn) return false;

            return finalTurn.was_truncated ||
                   finalTurn.no_question_found ||
                   finalTurn.boundary_a_context_error ||
                   finalTurn.boundary_b_context_error ||
                   finalTurn.answer_key_context_error;
        }

        function getIssuesList(conv) {
            const finalTurn = (conv.turns || []).find(t => t.is_final);
            const issues = [];

            if (finalTurn) {
                if (finalTurn.was_truncated) issues.push('Final question was too long and was truncated');
                if (finalTurn.no_question_found) issues.push('No question could be parsed from the response');
                if (finalTurn.boundary_a_context_error) issues.push('Boundary Model A ran out of context while answering');
                if (finalTurn.boundary_b_context_error) issues.push('Boundary Model B ran out of context while answering');
                if (finalTurn.answer_key_context_error) issues.push('Answer Key model ran out of context while answering');
            }

            // If has_issue is true but no specific issues found, show generic message
            if (conv.has_issue && issues.length === 0) {
                issues.push('Issue detected during evaluation');
            }

            return issues;
        }

        function switchTab(tabName) {
            currentTab = tabName;

            // Update button states
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.tab-button[onclick="switchTab('${tabName}')"]`).classList.add('active');

            // Update content visibility
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Render the appropriate heatmap if not already rendered
            if (tabName === 'difficulty' && !document.getElementById('heatmap-too-easy').hasChildNodes()) {
                renderDifficultyHeatmaps();
            } else if (tabName === 'issues' && !document.getElementById('heatmap-issues').hasChildNodes()) {
                renderIssuesHeatmap();
            }
        }

        function renderPage() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';

            const meta = evalData.metadata;
            const stats = evalData.overall_stats;

            // Header
            document.getElementById('model-name').textContent = meta.questioner_model;
            document.getElementById('accuracy-value').textContent =
                (stats.accuracy * 100).toFixed(1) + '%';

            // Stats row
            const statsRow = document.getElementById('stats-row');
            statsRow.innerHTML = `
                <div class="stat-item">
                    <span>Answer Key:</span>
                    <span class="stat-value">${meta.answer_key_model}</span>
                </div>
                <div class="stat-item">
                    <span>Boundary Models:</span>
                    <span class="stat-value">${meta.num_boundary_models}</span>
                </div>
                <div class="stat-item">
                    <span>Pairs:</span>
                    <span class="stat-value">${meta.num_pairs}</span>
                </div>
                <div class="stat-item">
                    <span>Total Rollouts:</span>
                    <span class="stat-value">${meta.total_rollouts}</span>
                </div>
                <div class="stat-item">
                    <span>Max Turns:</span>
                    <span class="stat-value">${meta.max_turns}</span>
                </div>
            `;

            // Difficulty bar
            const total = stats.too_easy + stats.calibrated + stats.too_hard;
            const tooEasyPct = (stats.too_easy / total * 100).toFixed(1);
            const calibratedPct = (stats.calibrated / total * 100).toFixed(1);
            const tooHardPct = (stats.too_hard / total * 100).toFixed(1);

            document.getElementById('difficulty-bar').innerHTML = `
                <div class="difficulty-segment too-easy" style="width: ${tooEasyPct}%">${tooEasyPct}%</div>
                <div class="difficulty-segment calibrated" style="width: ${calibratedPct}%">${calibratedPct}%</div>
                <div class="difficulty-segment too-hard" style="width: ${tooHardPct}%">${tooHardPct}%</div>
            `;

            document.getElementById('difficulty-legend').innerHTML = `
                <div class="difficulty-legend-item">
                    <span class="difficulty-legend-color too-easy"></span>
                    <span>Too Easy (${stats.too_easy})</span>
                </div>
                <div class="difficulty-legend-item">
                    <span class="difficulty-legend-color calibrated"></span>
                    <span>Calibrated (${stats.calibrated})</span>
                </div>
                <div class="difficulty-legend-item">
                    <span class="difficulty-legend-color too-hard"></span>
                    <span>Too Hard (${stats.too_hard})</span>
                </div>
            `;

            // Issues bar
            const issuesPct = (stats.pct_rollouts_with_issues * 100);
            const issuesFill = document.getElementById('issues-bar-fill');
            const issuesLabel = document.getElementById('issues-bar-label');

            if (issuesPct > 0) {
                issuesFill.style.width = `${issuesPct}%`;
                issuesFill.textContent = `${issuesPct.toFixed(1)}%`;
                issuesLabel.textContent = '';
            } else {
                issuesFill.style.width = '0%';
                issuesFill.textContent = '';
                issuesLabel.textContent = 'No issues (0%)';
            }

            // Populate model selects
            populateModelSelects();

            // Render main heatmap
            renderAccuracyHeatmap();

            // Set up event listeners
            document.getElementById('model-a-select').addEventListener('change', onPairChange);
            document.getElementById('model-b-select').addEventListener('change', onPairChange);
            document.getElementById('filter-select').addEventListener('change', onFilterChange);
        }

        function populateModelSelects() {
            const models = evalData.boundary_models;
            const selectA = document.getElementById('model-a-select');
            const selectB = document.getElementById('model-b-select');

            models.forEach(model => {
                selectA.innerHTML += `<option value="${model}">${model}</option>`;
                selectB.innerHTML += `<option value="${model}">${model}</option>`;
            });

            // Set default selection if there are at least 2 models
            if (models.length >= 2) {
                selectA.value = models[0];
                selectB.value = models[1];
                onPairChange();
            }
        }

        function renderAccuracyHeatmap() {
            const models = evalData.boundary_models;
            const n = models.length;

            // Build z-values for upper triangular heatmap
            const z = [];
            const text = [];
            for (let i = 0; i < n; i++) {
                const row = [];
                const textRow = [];
                for (let j = 0; j < n; j++) {
                    if (i < j) {
                        const pairKey = `${models[i]}|${models[j]}`;
                        const acc = evalData.pairwise_accuracy[pairKey];
                        if (acc !== undefined) {
                            row.push(acc);
                            textRow.push(`${(acc * 100).toFixed(0)}%`);
                        } else {
                            row.push(null);
                            textRow.push('');
                        }
                    } else {
                        row.push(null);
                        textRow.push('');
                    }
                }
                z.push(row);
                text.push(textRow);
            }

            const heatmapData = [{
                z: z,
                x: models,
                y: models,
                type: 'heatmap',
                colorscale: [
                    [0, '#ffcdd2'],
                    [0.5, '#fff9c4'],
                    [1, '#c8e6c9']
                ],
                zmin: 0,
                zmax: 1,
                text: text,
                texttemplate: '%{text}',
                textfont: { size: 14, color: '#333' },
                hoverongaps: false,
                hovertemplate: '%{y} vs %{x}<br>Accuracy: %{text}<extra></extra>',
                showscale: true,
                colorbar: {
                    title: 'Accuracy',
                    tickformat: '.0%'
                }
            }];

            const layout = {
                width: 1000,
                height: 800,
                xaxis: {
                    tickangle: -45,
                    tickfont: { size: 11 },
                    tickmode: 'linear',
                    tick0: 0,
                    dtick: 1
                },
                yaxis: {
                    autorange: 'reversed',
                    tickfont: { size: 11 },
                    tickmode: 'linear',
                    tick0: 0,
                    dtick: 1
                },
                margin: { l: 180, r: 100, t: 30, b: 180 }
            };

            Plotly.newPlot('heatmap-accuracy', heatmapData, layout, { responsive: true });

            // Click handler for heatmap
            document.getElementById('heatmap-accuracy').on('plotly_click', function(data) {
                const point = data.points[0];
                if (point.z !== null) {
                    document.getElementById('model-a-select').value = point.y;
                    document.getElementById('model-b-select').value = point.x;
                    document.getElementById('filter-select').value = 'all';
                    currentFilter = 'all';
                    onPairChange();
                }
            });
        }

        function renderDifficultyHeatmaps() {
            const models = evalData.boundary_models;
            const n = models.length;

            // Build matrices for each difficulty type
            const buildMatrix = (statKey) => {
                const z = [];
                const text = [];
                for (let i = 0; i < n; i++) {
                    const row = [];
                    const textRow = [];
                    for (let j = 0; j < n; j++) {
                        if (i < j) {
                            const pairKey = `${models[i]}|${models[j]}`;
                            const stats = pairwiseStats[pairKey];
                            if (stats) {
                                const val = stats[statKey];
                                row.push(val);
                                textRow.push(`${(val * 100).toFixed(0)}%`);
                            } else {
                                row.push(null);
                                textRow.push('');
                            }
                        } else {
                            row.push(null);
                            textRow.push('');
                        }
                    }
                    z.push(row);
                    text.push(textRow);
                }
                return { z, text };
            };

            const miniLayout = {
                width: 350,
                height: 350,
                xaxis: {
                    tickangle: -45,
                    tickfont: { size: 9 },
                    tickmode: 'linear'
                },
                yaxis: {
                    autorange: 'reversed',
                    tickfont: { size: 9 },
                    tickmode: 'linear'
                },
                margin: { l: 100, r: 20, t: 10, b: 100 }
            };

            // Click handler for difficulty heatmaps
            const difficultyClickHandler = function(data) {
                const point = data.points[0];
                if (point.z !== null) {
                    document.getElementById('model-a-select').value = point.y;
                    document.getElementById('model-b-select').value = point.x;
                    document.getElementById('filter-select').value = 'all';
                    currentFilter = 'all';
                    onPairChange();
                }
            };

            // Too Easy heatmap (white to orange)
            const tooEasyData = buildMatrix('tooEasyPct');
            Plotly.newPlot('heatmap-too-easy', [{
                z: tooEasyData.z,
                x: models,
                y: models,
                type: 'heatmap',
                colorscale: [[0, '#ffffff'], [1, '#ffb74d']],
                zmin: 0,
                zmax: 1,
                text: tooEasyData.text,
                texttemplate: '%{text}',
                textfont: { size: 10, color: '#333' },
                hoverongaps: false,
                showscale: false
            }], miniLayout, { responsive: true });
            document.getElementById('heatmap-too-easy').on('plotly_click', difficultyClickHandler);

            // Calibrated heatmap (white to green)
            const calibratedData = buildMatrix('calibratedPct');
            Plotly.newPlot('heatmap-calibrated', [{
                z: calibratedData.z,
                x: models,
                y: models,
                type: 'heatmap',
                colorscale: [[0, '#ffffff'], [1, '#81c784']],
                zmin: 0,
                zmax: 1,
                text: calibratedData.text,
                texttemplate: '%{text}',
                textfont: { size: 10, color: '#333' },
                hoverongaps: false,
                showscale: false
            }], miniLayout, { responsive: true });
            document.getElementById('heatmap-calibrated').on('plotly_click', difficultyClickHandler);

            // Too Hard heatmap (white to red)
            const tooHardData = buildMatrix('tooHardPct');
            Plotly.newPlot('heatmap-too-hard', [{
                z: tooHardData.z,
                x: models,
                y: models,
                type: 'heatmap',
                colorscale: [[0, '#ffffff'], [1, '#e57373']],
                zmin: 0,
                zmax: 1,
                text: tooHardData.text,
                texttemplate: '%{text}',
                textfont: { size: 10, color: '#333' },
                hoverongaps: false,
                showscale: false
            }], miniLayout, { responsive: true });
            document.getElementById('heatmap-too-hard').on('plotly_click', difficultyClickHandler);
        }

        function renderIssuesHeatmap() {
            const models = evalData.boundary_models;
            const n = models.length;

            const z = [];
            const text = [];
            for (let i = 0; i < n; i++) {
                const row = [];
                const textRow = [];
                for (let j = 0; j < n; j++) {
                    if (i < j) {
                        const pairKey = `${models[i]}|${models[j]}`;
                        const stats = pairwiseStats[pairKey];
                        if (stats) {
                            row.push(stats.issuesPct);
                            textRow.push(`${(stats.issuesPct * 100).toFixed(0)}%`);
                        } else {
                            row.push(null);
                            textRow.push('');
                        }
                    } else {
                        row.push(null);
                        textRow.push('');
                    }
                }
                z.push(row);
                text.push(textRow);
            }

            const heatmapData = [{
                z: z,
                x: models,
                y: models,
                type: 'heatmap',
                colorscale: [
                    [0, '#e8f5e9'],
                    [0.5, '#fff9c4'],
                    [1, '#ffcdd2']
                ],
                zmin: 0,
                zmax: 1,
                text: text,
                texttemplate: '%{text}',
                textfont: { size: 14, color: '#333' },
                hoverongaps: false,
                hovertemplate: '%{y} vs %{x}<br>Issues: %{text}<extra></extra>',
                showscale: true,
                colorbar: {
                    title: 'Issues %',
                    tickformat: '.0%'
                }
            }];

            const layout = {
                width: 1000,
                height: 800,
                xaxis: {
                    tickangle: -45,
                    tickfont: { size: 11 },
                    tickmode: 'linear',
                    tick0: 0,
                    dtick: 1
                },
                yaxis: {
                    autorange: 'reversed',
                    tickfont: { size: 11 },
                    tickmode: 'linear',
                    tick0: 0,
                    dtick: 1
                },
                margin: { l: 180, r: 100, t: 30, b: 180 }
            };

            Plotly.newPlot('heatmap-issues', heatmapData, layout, { responsive: true });

            // Click handler - filter to issues only
            document.getElementById('heatmap-issues').on('plotly_click', function(data) {
                const point = data.points[0];
                if (point.z !== null) {
                    document.getElementById('model-a-select').value = point.y;
                    document.getElementById('model-b-select').value = point.x;
                    document.getElementById('filter-select').value = 'issues';
                    currentFilter = 'issues';
                    onPairChange();
                }
            });
        }

        function onFilterChange() {
            currentFilter = document.getElementById('filter-select').value;
            applyFilter();
        }

        function applyFilter() {
            if (currentFilter === 'issues') {
                currentConversations = allConversationsForPair.filter(c => hasIssues(c));
            } else {
                currentConversations = allConversationsForPair;
            }
            currentConvIndex = 0;
            document.getElementById('conv-total').textContent = currentConversations.length;
            displayConversation(currentConvIndex);
        }

        function onPairChange() {
            currentModelA = document.getElementById('model-a-select').value;
            currentModelB = document.getElementById('model-b-select').value;

            if (currentModelA === currentModelB) {
                document.getElementById('pair-accuracy').textContent = '--';
                document.getElementById('pair-stats').textContent = '';
                document.getElementById('conversation-display').innerHTML = `
                    <div class="no-selection">
                        <p>Please select two different models</p>
                    </div>
                `;
                return;
            }

            // Get conversations for this pair
            const key1 = `${currentModelA}|${currentModelB}`;
            const key2 = `${currentModelB}|${currentModelA}`;
            allConversationsForPair = evalData.conversations[key1] || evalData.conversations[key2] || [];

            // Apply filter
            applyFilter();

            // Get pairwise accuracy
            const pairwise = evalData.pairwise_accuracy;
            const accuracy = pairwise[key1] !== undefined ? pairwise[key1] : pairwise[key2];

            document.getElementById('pair-accuracy').textContent =
                accuracy !== undefined ? (accuracy * 100).toFixed(1) + '%' : '--';

            // Count outcomes
            let calibrated = 0, tooEasy = 0, tooHard = 0, withIssues = 0;
            allConversationsForPair.forEach(c => {
                if (c.outcome === 'calibrated') calibrated++;
                else if (c.outcome === 'too_easy') tooEasy++;
                else if (c.outcome === 'too_hard') tooHard++;
                if (hasIssues(c)) withIssues++;
            });
            document.getElementById('pair-stats').textContent =
                `(${calibrated} calibrated, ${tooEasy} too easy, ${tooHard} too hard, ${withIssues} with issues)`;
        }

        function displayConversation(index) {
            if (currentConversations.length === 0) {
                document.getElementById('conversation-display').innerHTML = `
                    <div class="no-selection">
                        <p>No conversations found${currentFilter === 'issues' ? ' with issues' : ''} for this pair</p>
                    </div>
                `;
                return;
            }

            const conv = currentConversations[index];
            if (!conv) return;

            const modelA = currentModelA;
            const modelB = currentModelB;
            const reward = conv.reward;
            const maxTurns = evalData.metadata.max_turns;

            // Check for issues
            const issues = getIssuesList(conv);
            let issuesHtml = '';
            if (issues.length > 0) {
                issuesHtml = `
                    <div class="issues-alert">
                        <div class="issues-alert-title">&#9888; Issues Detected in Final Question</div>
                        <ul class="issues-alert-list">
                            ${issues.map(issue => `<li>${issue}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Use pre-computed correctness values
            const extractedA = conv.extracted_a || '';
            const extractedB = conv.extracted_b || '';
            const extractedKey = conv.extracted_key || '';
            const aCorrect = conv.a_correct;
            const bCorrect = conv.b_correct;

            // Determine dial outcome
            let dialOutcome, dialRotation, dialExplanation;
            if (aCorrect && !bCorrect) {
                dialOutcome = 'calibrated';
                dialRotation = 0;
                dialExplanation = `<strong>Success!</strong> The questioner generated a question that differentiates the boundary models. <strong>${modelA}</strong> answered correctly while <strong>${modelB}</strong> got it wrong.`;
            } else if (!aCorrect && bCorrect) {
                dialOutcome = 'calibrated';
                dialRotation = 0;
                dialExplanation = `<strong>Success!</strong> The questioner generated a question that differentiates the boundary models. <strong>${modelB}</strong> answered correctly while <strong>${modelA}</strong> got it wrong.`;
            } else if (aCorrect && bCorrect) {
                dialOutcome = 'too-easy';
                dialRotation = -60;
                dialExplanation = `<strong>Too Easy.</strong> Both boundary models answered correctly. The question was not difficult enough to differentiate them.`;
            } else {
                dialOutcome = 'too-hard';
                dialRotation = 60;
                dialExplanation = `<strong>Too Hard.</strong> Both boundary models answered incorrectly. The question was too difficult for either model.`;
            }

            // Build turns HTML from turns data
            const turns = conv.turns || [];
            let turnsHtml = '';

            // Build HTML for each probing turn (not the final one)
            for (let i = 0; i < turns.length; i++) {
                const turnData = turns[i];
                if (turnData.is_final) continue;  // Skip final turn, shown separately

                const turnNum = turnData.turn_number || (i + 1);
                const fullResponse = turnData.full_response || '';
                const parsedQuestion = turnData.question || '';
                const boundaryAAnswer = turnData.boundary_a_answer || '';
                const boundaryBAnswer = turnData.boundary_b_answer || '';

                turnsHtml += `
                    <div class="turn">
                        <div class="turn-header probing">
                            <span>Probing Question ${turnNum}</span>
                            <span class="turn-number">Turn ${turnNum} of ${maxTurns}</span>
                        </div>
                        <div class="turn-content">
                            <div class="field">
                                <div class="field-label">Questioner Response <span style="font-size: 10px; color: #666;">(highlighted = sent to boundary models)</span></div>
                                <div class="field-value">${formatQuestionerResponse(fullResponse, parsedQuestion)}</div>
                            </div>
                            ${boundaryAAnswer || boundaryBAnswer ? `
                            <div class="field">
                                <div class="field-label">Boundary Model Responses</div>
                                <div class="student-responses">
                                    <div class="student-box">
                                        <div class="student-name">Boundary A: ${modelA}</div>
                                        <div class="student-answer">${escapeHtml(boundaryAAnswer)}</div>
                                    </div>
                                    <div class="student-box">
                                        <div class="student-name">Boundary B: ${modelB}</div>
                                        <div class="student-answer">${escapeHtml(boundaryBAnswer)}</div>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // Get final turn data
            const finalTurn = turns.find(t => t.is_final) || {};
            const finalFullResponse = finalTurn.full_response || '';
            const finalParsedQuestion = finalTurn.question || '';

            const html = `
                ${issuesHtml}

                <!-- Dial visualization -->
                <div class="dial-section">
                    <div class="dial-container">
                        <svg width="180" height="110" viewBox="0 0 180 110">
                            <!-- Background arc -->
                            <path d="M 18 90 A 72 72 0 0 1 162 90"
                                  fill="none"
                                  stroke="#e0e0e0"
                                  stroke-width="20"/>
                            <!-- Too Easy zone (left) -->
                            <path d="M 18 90 A 72 72 0 0 1 54 28.3"
                                  fill="none"
                                  stroke="#ffb74d"
                                  stroke-width="18"
                                  stroke-linecap="butt"/>
                            <!-- Calibrated zone (center) -->
                            <path d="M 54 28.3 A 72 72 0 0 1 126 28.3"
                                  fill="none"
                                  stroke="#81c784"
                                  stroke-width="18"
                                  stroke-linecap="butt"/>
                            <!-- Too Hard zone (right) -->
                            <path d="M 126 28.3 A 72 72 0 0 1 162 90"
                                  fill="none"
                                  stroke="#e57373"
                                  stroke-width="18"
                                  stroke-linecap="butt"/>
                            <!-- Needle -->
                            <g transform="rotate(${dialRotation}, 90, 90)">
                                <polygon points="90,24 86,90 94,90" fill="#333"/>
                                <circle cx="90" cy="90" r="9" fill="#333"/>
                            </g>
                            <!-- Labels -->
                            <text x="10" y="105" font-size="10" fill="#666" font-weight="500">Easy</text>
                            <text x="145" y="105" font-size="10" fill="#666" font-weight="500">Hard</text>
                        </svg>
                        <div class="dial-label ${dialOutcome}">${dialOutcome === 'calibrated' ? 'Calibrated' : (dialOutcome === 'too-easy' ? 'Too Easy' : 'Too Hard')}</div>
                    </div>
                    <div class="dial-explanation">
                        ${dialExplanation}
                    </div>
                </div>

                <!-- Final evaluation -->
                <div class="final-evaluation">
                    <h3>Final Evaluation (Turn ${maxTurns} of ${maxTurns})</h3>

                    <div class="field">
                        <div class="field-label">Final Differentiating Question <span style="font-size: 10px; color: #666;">(highlighted = sent to boundary models)</span></div>
                        <div class="field-value">${formatQuestionerResponse(finalFullResponse, finalParsedQuestion)}</div>
                    </div>

                    <div class="field">
                        <div class="field-label">Boundary Model Responses</div>
                        <div class="student-responses">
                            <div class="student-box">
                                <div class="student-name">Boundary A: ${modelA}</div>
                                <div class="student-answer">${escapeHtml(conv.final_boundary_a_answer)}</div>
                            </div>
                            <div class="student-box">
                                <div class="student-name">Boundary B: ${modelB}</div>
                                <div class="student-answer">${escapeHtml(conv.final_boundary_b_answer)}</div>
                            </div>
                        </div>
                    </div>

                    <div class="extracted-answers">
                        <div class="extracted-box">
                            <div class="extracted-label">Answer Key</div>
                            <div class="extracted-value key">${escapeHtml(extractedKey) || 'N/A'}</div>
                        </div>
                        <div class="extracted-box">
                            <div class="extracted-label">Boundary A (${modelA})</div>
                            <div class="extracted-value ${aCorrect ? 'correct' : 'incorrect'}">${escapeHtml(extractedA) || 'N/A'} ${aCorrect ? '&#10003;' : '&#10007;'}</div>
                        </div>
                        <div class="extracted-box">
                            <div class="extracted-label">Boundary B (${modelB})</div>
                            <div class="extracted-value ${bCorrect ? 'correct' : 'incorrect'}">${escapeHtml(extractedB) || 'N/A'} ${bCorrect ? '&#10003;' : '&#10007;'}</div>
                        </div>
                    </div>

                    <div>
                        <strong>Reward:</strong>
                        <span class="reward-badge ${reward > 0 ? 'success' : 'failure'}">${reward} - ${reward > 0 ? 'Exactly one boundary model correct' : 'Both correct or both wrong'}</span>
                    </div>

                    <div class="answer-key-section">
                        <div class="answer-key-label">Full Answer Key Response</div>
                        <div class="answer-key-value">${escapeHtml(conv.answer_key_answer)}</div>
                    </div>
                </div>

                <!-- Conversation turns -->
                <div class="conversation">
                    ${turnsHtml}
                </div>
            `;

            document.getElementById('conversation-display').innerHTML = html;
            document.getElementById('conv-current').textContent = index + 1;
            updateNavButtons();
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatQuestionerResponse(fullResponse, parsedQuestion) {
            // Show full response with parsed question highlighted
            if (!fullResponse) return escapeHtml(parsedQuestion || '');
            if (!parsedQuestion || fullResponse === parsedQuestion) return escapeHtml(fullResponse);

            const escapedFull = escapeHtml(fullResponse);
            const escapedParsed = escapeHtml(parsedQuestion);

            // Highlight the LAST occurrence of the parsed question within the full response
            const lastIndex = escapedFull.lastIndexOf(escapedParsed);
            if (lastIndex !== -1) {
                const before = escapedFull.substring(0, lastIndex);
                const highlighted = `<strong style="background: #fff3cd; padding: 2px 4px; border-radius: 3px; border: 1px solid #ffc107;">${escapedParsed}</strong>`;
                const after = escapedFull.substring(lastIndex + escapedParsed.length);
                return before + highlighted + after;
            }
            // Fallback: show both separately
            return escapedFull + '<br><br><strong style="background: #fff3cd; padding: 2px 4px; border-radius: 3px;">Parsed question:</strong> ' + escapedParsed;
        }

        function updateNavButtons() {
            document.getElementById('prev-btn').disabled = currentConvIndex === 0;
            document.getElementById('next-btn').disabled = currentConvIndex >= currentConversations.length - 1;
        }

        function prevConversation() {
            if (currentConvIndex > 0) {
                currentConvIndex--;
                displayConversation(currentConvIndex);
            }
        }

        function nextConversation() {
            if (currentConvIndex < currentConversations.length - 1) {
                currentConvIndex++;
                displayConversation(currentConvIndex);
            }
        }

        // Initialize on page load
        init();
    </script>
</body>
</html>
