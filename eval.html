<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIAL-RL Evaluation</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <!-- Navigation -->
        <nav class="nav-bar">
            <a href="index.html" class="back-link">&#8592; Back to Model Comparison</a>
        </nav>

        <!-- Loading state -->
        <div id="loading" class="loading">
            <div class="loading-spinner"></div>
            <p>Loading evaluation data...</p>
        </div>

        <!-- Error state -->
        <div id="error" class="error" style="display: none;">
            <div class="error-icon">&#9888;</div>
            <p id="error-message">Failed to load evaluation data.</p>
        </div>

        <!-- Main content (hidden until loaded) -->
        <div id="main-content" style="display: none;">
            <!-- Header with model name and overall accuracy -->
            <div class="header">
                <div class="model-name" id="model-name"></div>
                <div class="accuracy-display">
                    <span class="accuracy-value" id="accuracy-value"></span>
                    <span class="accuracy-label">Overall Accuracy</span>
                </div>
                <div class="stats-row" id="stats-row"></div>
                <!-- Difficulty Calibration Stats -->
                <div class="difficulty-stats">
                    <div class="difficulty-title">Question Difficulty Distribution</div>
                    <div class="difficulty-bar" id="difficulty-bar"></div>
                    <div class="difficulty-legend" id="difficulty-legend"></div>
                </div>
            </div>

            <!-- Pairwise accuracy heatmap -->
            <div class="heatmap-section">
                <div class="section-title">Pairwise Accuracy Matrix</div>
                <div class="heatmap-container">
                    <div id="heatmap"></div>
                </div>
            </div>

            <!-- Conversation explorer -->
            <div class="explorer-section">
                <div class="section-title">Conversation Explorer</div>

                <div class="explorer-controls">
                    <div class="control-group">
                        <label class="control-label">Boundary Model A</label>
                        <select id="model-a-select"></select>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Boundary Model B</label>
                        <select id="model-b-select"></select>
                    </div>
                    <div class="pair-accuracy">
                        <span>Pair Accuracy: </span>
                        <span class="pair-accuracy-value" id="pair-accuracy">--</span>
                        <span id="pair-stats"></span>
                    </div>
                </div>

                <div class="conv-nav">
                    <div class="conv-nav-buttons">
                        <button id="prev-btn" onclick="prevConversation()">&#8592; Previous</button>
                        <button id="next-btn" onclick="nextConversation()">Next &#8594;</button>
                    </div>
                    <div class="conv-counter">
                        Conversation <span id="conv-current">1</span> of <span id="conv-total">0</span>
                    </div>
                </div>

                <div id="conversation-display">
                    <div class="no-selection">
                        <div class="no-selection-icon">&#128172;</div>
                        <p>Select a model pair to view conversations</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get model name from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const modelName = urlParams.get('model');

        // Store loaded data
        let evalData = null;
        let currentConvIndex = 0;
        let currentConversations = [];
        let currentModelA = '';
        let currentModelB = '';

        // Load data and initialize
        async function init() {
            if (!modelName) {
                showError('No model specified. Use ?model=model-name in the URL.');
                return;
            }

            try {
                const response = await fetch(`data/${modelName}.json`);
                if (!response.ok) {
                    throw new Error(`Could not load data for model: ${modelName}`);
                }
                evalData = await response.json();

                document.title = `DIAL-RL Evaluation: ${evalData.metadata.questioner_model}`;
                renderPage();
            } catch (e) {
                showError(e.message);
            }
        }

        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
            document.getElementById('error-message').textContent = message;
        }

        function renderPage() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';

            const meta = evalData.metadata;
            const stats = evalData.overall_stats;

            // Header
            document.getElementById('model-name').textContent = meta.questioner_model;
            document.getElementById('accuracy-value').textContent =
                (stats.accuracy * 100).toFixed(1) + '%';

            // Stats row
            const statsRow = document.getElementById('stats-row');
            statsRow.innerHTML = `
                <div class="stat-item">
                    <span>Answer Key:</span>
                    <span class="stat-value">${meta.answer_key_model}</span>
                </div>
                <div class="stat-item">
                    <span>Boundary Models:</span>
                    <span class="stat-value">${meta.num_boundary_models}</span>
                </div>
                <div class="stat-item">
                    <span>Pairs:</span>
                    <span class="stat-value">${meta.num_pairs}</span>
                </div>
                <div class="stat-item">
                    <span>Total Rollouts:</span>
                    <span class="stat-value">${meta.total_rollouts}</span>
                </div>
                <div class="stat-item">
                    <span>Max Turns:</span>
                    <span class="stat-value">${meta.max_turns}</span>
                </div>
            `;

            // Difficulty bar
            const total = stats.too_easy + stats.calibrated + stats.too_hard;
            const tooEasyPct = (stats.too_easy / total * 100).toFixed(1);
            const calibratedPct = (stats.calibrated / total * 100).toFixed(1);
            const tooHardPct = (stats.too_hard / total * 100).toFixed(1);

            document.getElementById('difficulty-bar').innerHTML = `
                <div class="difficulty-segment too-easy" style="width: ${tooEasyPct}%">${tooEasyPct}%</div>
                <div class="difficulty-segment calibrated" style="width: ${calibratedPct}%">${calibratedPct}%</div>
                <div class="difficulty-segment too-hard" style="width: ${tooHardPct}%">${tooHardPct}%</div>
            `;

            document.getElementById('difficulty-legend').innerHTML = `
                <div class="difficulty-legend-item">
                    <span class="difficulty-legend-color too-easy"></span>
                    <span>Too Easy (${stats.too_easy})</span>
                </div>
                <div class="difficulty-legend-item">
                    <span class="difficulty-legend-color calibrated"></span>
                    <span>Calibrated (${stats.calibrated})</span>
                </div>
                <div class="difficulty-legend-item">
                    <span class="difficulty-legend-color too-hard"></span>
                    <span>Too Hard (${stats.too_hard})</span>
                </div>
            `;

            // Populate model selects
            populateModelSelects();

            // Render heatmap
            renderHeatmap();

            // Set up event listeners
            document.getElementById('model-a-select').addEventListener('change', onPairChange);
            document.getElementById('model-b-select').addEventListener('change', onPairChange);
        }

        function populateModelSelects() {
            const models = evalData.boundary_models;
            const selectA = document.getElementById('model-a-select');
            const selectB = document.getElementById('model-b-select');

            models.forEach(model => {
                selectA.innerHTML += `<option value="${model}">${model}</option>`;
                selectB.innerHTML += `<option value="${model}">${model}</option>`;
            });

            // Set default selection if there are at least 2 models
            if (models.length >= 2) {
                selectA.value = models[0];
                selectB.value = models[1];
                onPairChange();
            }
        }

        function renderHeatmap() {
            const models = evalData.boundary_models;
            const n = models.length;

            // Build z-values for upper triangular heatmap
            const z = [];
            const text = [];
            for (let i = 0; i < n; i++) {
                const row = [];
                const textRow = [];
                for (let j = 0; j < n; j++) {
                    if (i < j) {
                        const pairKey = `${models[i]}|${models[j]}`;
                        const acc = evalData.pairwise_accuracy[pairKey];
                        if (acc !== undefined) {
                            row.push(acc);
                            textRow.push(`${(acc * 100).toFixed(0)}%`);
                        } else {
                            row.push(null);
                            textRow.push('');
                        }
                    } else {
                        row.push(null);
                        textRow.push('');
                    }
                }
                z.push(row);
                text.push(textRow);
            }

            const heatmapData = [{
                z: z,
                x: models,
                y: models,
                type: 'heatmap',
                colorscale: [
                    [0, '#ffcdd2'],
                    [0.5, '#fff9c4'],
                    [1, '#c8e6c9']
                ],
                zmin: 0,
                zmax: 1,
                text: text,
                texttemplate: '%{text}',
                textfont: { size: 14, color: '#333' },
                hoverongaps: false,
                hovertemplate: '%{y} vs %{x}<br>Accuracy: %{text}<extra></extra>',
                showscale: true,
                colorbar: {
                    title: 'Accuracy',
                    tickformat: '.0%'
                }
            }];

            // Fixed large size regardless of number of models
            const width = 1000;
            const height = 800;

            const layout = {
                width: width,
                height: height,
                xaxis: {
                    tickangle: -45,
                    tickfont: { size: 11 },
                    tickmode: 'linear',
                    tick0: 0,
                    dtick: 1
                },
                yaxis: {
                    autorange: 'reversed',
                    tickfont: { size: 11 },
                    tickmode: 'linear',
                    tick0: 0,
                    dtick: 1
                },
                margin: { l: 180, r: 100, t: 30, b: 180 }
            };

            Plotly.newPlot('heatmap', heatmapData, layout, { responsive: true });

            // Click handler for heatmap
            document.getElementById('heatmap').on('plotly_click', function(data) {
                const point = data.points[0];
                if (point.z !== null) {
                    document.getElementById('model-a-select').value = point.y;
                    document.getElementById('model-b-select').value = point.x;
                    onPairChange();
                }
            });
        }

        function onPairChange() {
            currentModelA = document.getElementById('model-a-select').value;
            currentModelB = document.getElementById('model-b-select').value;

            if (currentModelA === currentModelB) {
                document.getElementById('pair-accuracy').textContent = '--';
                document.getElementById('pair-stats').textContent = '';
                document.getElementById('conversation-display').innerHTML = `
                    <div class="no-selection">
                        <p>Please select two different models</p>
                    </div>
                `;
                return;
            }

            // Get conversations for this pair
            const key1 = `${currentModelA}|${currentModelB}`;
            const key2 = `${currentModelB}|${currentModelA}`;
            currentConversations = evalData.conversations[key1] || evalData.conversations[key2] || [];
            currentConvIndex = 0;

            // Get pairwise accuracy
            const pairwise = evalData.pairwise_accuracy;
            const accuracy = pairwise[key1] !== undefined ? pairwise[key1] : pairwise[key2];

            document.getElementById('pair-accuracy').textContent =
                accuracy !== undefined ? (accuracy * 100).toFixed(1) + '%' : '--';

            // Count outcomes
            let calibrated = 0, tooEasy = 0, tooHard = 0;
            currentConversations.forEach(c => {
                if (c.outcome === 'calibrated') calibrated++;
                else if (c.outcome === 'too_easy') tooEasy++;
                else if (c.outcome === 'too_hard') tooHard++;
            });
            document.getElementById('pair-stats').textContent =
                `(${calibrated} calibrated, ${tooEasy} too easy, ${tooHard} too hard)`;

            document.getElementById('conv-total').textContent = currentConversations.length;
            displayConversation(currentConvIndex);
        }

        function displayConversation(index) {
            if (currentConversations.length === 0) {
                document.getElementById('conversation-display').innerHTML = `
                    <div class="no-selection">
                        <p>No conversations found for this pair</p>
                    </div>
                `;
                return;
            }

            const conv = currentConversations[index];
            if (!conv) return;

            const modelA = currentModelA;
            const modelB = currentModelB;
            const reward = conv.reward;
            const maxTurns = evalData.metadata.max_turns;

            // Use pre-computed correctness values
            const extractedA = conv.extracted_a || '';
            const extractedB = conv.extracted_b || '';
            const extractedKey = conv.extracted_key || '';
            const aCorrect = conv.a_correct;
            const bCorrect = conv.b_correct;

            // Determine dial outcome
            let dialOutcome, dialRotation, dialExplanation;
            if (aCorrect && !bCorrect) {
                dialOutcome = 'calibrated';
                dialRotation = 0;
                dialExplanation = `<strong>Success!</strong> The questioner generated a question that differentiates the boundary models. <strong>${modelA}</strong> answered correctly while <strong>${modelB}</strong> got it wrong.`;
            } else if (!aCorrect && bCorrect) {
                dialOutcome = 'calibrated';
                dialRotation = 0;
                dialExplanation = `<strong>Success!</strong> The questioner generated a question that differentiates the boundary models. <strong>${modelB}</strong> answered correctly while <strong>${modelA}</strong> got it wrong.`;
            } else if (aCorrect && bCorrect) {
                dialOutcome = 'too-easy';
                dialRotation = -60;
                dialExplanation = `<strong>Too Easy.</strong> Both boundary models answered correctly. The question was not difficult enough to differentiate them.`;
            } else {
                dialOutcome = 'too-hard';
                dialRotation = 60;
                dialExplanation = `<strong>Too Hard.</strong> Both boundary models answered incorrectly. The question was too difficult for either model.`;
            }

            // Build turns HTML from turns data
            const turns = conv.turns || [];
            let turnsHtml = '';

            // Build HTML for each probing turn (not the final one)
            for (let i = 0; i < turns.length; i++) {
                const turnData = turns[i];
                if (turnData.is_final) continue;  // Skip final turn, shown separately

                const turnNum = turnData.turn_number || (i + 1);
                const fullResponse = turnData.full_response || '';
                const parsedQuestion = turnData.question || '';
                const boundaryAAnswer = turnData.boundary_a_answer || '';
                const boundaryBAnswer = turnData.boundary_b_answer || '';

                turnsHtml += `
                    <div class="turn">
                        <div class="turn-header probing">
                            <span>Probing Question ${turnNum}</span>
                            <span class="turn-number">Turn ${turnNum} of ${maxTurns}</span>
                        </div>
                        <div class="turn-content">
                            <div class="field">
                                <div class="field-label">Questioner Response <span style="font-size: 10px; color: #666;">(highlighted = sent to boundary models)</span></div>
                                <div class="field-value">${formatQuestionerResponse(fullResponse, parsedQuestion)}</div>
                            </div>
                            ${boundaryAAnswer || boundaryBAnswer ? `
                            <div class="field">
                                <div class="field-label">Boundary Model Responses</div>
                                <div class="student-responses">
                                    <div class="student-box">
                                        <div class="student-name">Boundary A: ${modelA}</div>
                                        <div class="student-answer">${escapeHtml(boundaryAAnswer)}</div>
                                    </div>
                                    <div class="student-box">
                                        <div class="student-name">Boundary B: ${modelB}</div>
                                        <div class="student-answer">${escapeHtml(boundaryBAnswer)}</div>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // Get final turn data
            const finalTurn = turns.find(t => t.is_final) || {};
            const finalFullResponse = finalTurn.full_response || '';
            const finalParsedQuestion = finalTurn.question || '';

            const html = `
                <!-- Dial visualization -->
                <div class="dial-section">
                    <div class="dial-container">
                        <svg width="180" height="110" viewBox="0 0 180 110">
                            <!-- Background arc -->
                            <path d="M 18 90 A 72 72 0 0 1 162 90"
                                  fill="none"
                                  stroke="#e0e0e0"
                                  stroke-width="20"/>
                            <!-- Too Easy zone (left) -->
                            <path d="M 18 90 A 72 72 0 0 1 54 28.3"
                                  fill="none"
                                  stroke="#ffb74d"
                                  stroke-width="18"
                                  stroke-linecap="butt"/>
                            <!-- Calibrated zone (center) -->
                            <path d="M 54 28.3 A 72 72 0 0 1 126 28.3"
                                  fill="none"
                                  stroke="#81c784"
                                  stroke-width="18"
                                  stroke-linecap="butt"/>
                            <!-- Too Hard zone (right) -->
                            <path d="M 126 28.3 A 72 72 0 0 1 162 90"
                                  fill="none"
                                  stroke="#e57373"
                                  stroke-width="18"
                                  stroke-linecap="butt"/>
                            <!-- Needle -->
                            <g transform="rotate(${dialRotation}, 90, 90)">
                                <polygon points="90,24 86,90 94,90" fill="#333"/>
                                <circle cx="90" cy="90" r="9" fill="#333"/>
                            </g>
                            <!-- Labels -->
                            <text x="10" y="105" font-size="10" fill="#666" font-weight="500">Easy</text>
                            <text x="145" y="105" font-size="10" fill="#666" font-weight="500">Hard</text>
                        </svg>
                        <div class="dial-label ${dialOutcome}">${dialOutcome === 'calibrated' ? 'Calibrated' : (dialOutcome === 'too-easy' ? 'Too Easy' : 'Too Hard')}</div>
                    </div>
                    <div class="dial-explanation">
                        ${dialExplanation}
                    </div>
                </div>

                <!-- Final evaluation -->
                <div class="final-evaluation">
                    <h3>Final Evaluation (Turn ${maxTurns} of ${maxTurns})</h3>

                    <div class="field">
                        <div class="field-label">Final Differentiating Question <span style="font-size: 10px; color: #666;">(highlighted = sent to boundary models)</span></div>
                        <div class="field-value">${formatQuestionerResponse(finalFullResponse, finalParsedQuestion)}</div>
                    </div>

                    <div class="field">
                        <div class="field-label">Boundary Model Responses</div>
                        <div class="student-responses">
                            <div class="student-box">
                                <div class="student-name">Boundary A: ${modelA}</div>
                                <div class="student-answer">${escapeHtml(conv.final_boundary_a_answer)}</div>
                            </div>
                            <div class="student-box">
                                <div class="student-name">Boundary B: ${modelB}</div>
                                <div class="student-answer">${escapeHtml(conv.final_boundary_b_answer)}</div>
                            </div>
                        </div>
                    </div>

                    <div class="extracted-answers">
                        <div class="extracted-box">
                            <div class="extracted-label">Answer Key</div>
                            <div class="extracted-value key">${escapeHtml(extractedKey) || 'N/A'}</div>
                        </div>
                        <div class="extracted-box">
                            <div class="extracted-label">Boundary A (${modelA})</div>
                            <div class="extracted-value ${aCorrect ? 'correct' : 'incorrect'}">${escapeHtml(extractedA) || 'N/A'} ${aCorrect ? '&#10003;' : '&#10007;'}</div>
                        </div>
                        <div class="extracted-box">
                            <div class="extracted-label">Boundary B (${modelB})</div>
                            <div class="extracted-value ${bCorrect ? 'correct' : 'incorrect'}">${escapeHtml(extractedB) || 'N/A'} ${bCorrect ? '&#10003;' : '&#10007;'}</div>
                        </div>
                    </div>

                    <div>
                        <strong>Reward:</strong>
                        <span class="reward-badge ${reward > 0 ? 'success' : 'failure'}">${reward} - ${reward > 0 ? 'Exactly one boundary model correct' : 'Both correct or both wrong'}</span>
                    </div>

                    <div class="answer-key-section">
                        <div class="answer-key-label">Full Answer Key Response</div>
                        <div class="answer-key-value">${escapeHtml(conv.answer_key_answer)}</div>
                    </div>
                </div>

                <!-- Conversation turns -->
                <div class="conversation">
                    ${turnsHtml}
                </div>
            `;

            document.getElementById('conversation-display').innerHTML = html;
            document.getElementById('conv-current').textContent = index + 1;
            updateNavButtons();
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatQuestionerResponse(fullResponse, parsedQuestion) {
            // Show full response with parsed question highlighted
            if (!fullResponse) return escapeHtml(parsedQuestion || '');
            if (!parsedQuestion || fullResponse === parsedQuestion) return escapeHtml(fullResponse);

            const escapedFull = escapeHtml(fullResponse);
            const escapedParsed = escapeHtml(parsedQuestion);

            // Highlight the LAST occurrence of the parsed question within the full response
            const lastIndex = escapedFull.lastIndexOf(escapedParsed);
            if (lastIndex !== -1) {
                const before = escapedFull.substring(0, lastIndex);
                const highlighted = `<strong style="background: #fff3cd; padding: 2px 4px; border-radius: 3px; border: 1px solid #ffc107;">${escapedParsed}</strong>`;
                const after = escapedFull.substring(lastIndex + escapedParsed.length);
                return before + highlighted + after;
            }
            // Fallback: show both separately
            return escapedFull + '<br><br><strong style="background: #fff3cd; padding: 2px 4px; border-radius: 3px;">Parsed question:</strong> ' + escapedParsed;
        }

        function updateNavButtons() {
            document.getElementById('prev-btn').disabled = currentConvIndex === 0;
            document.getElementById('next-btn').disabled = currentConvIndex >= currentConversations.length - 1;
        }

        function prevConversation() {
            if (currentConvIndex > 0) {
                currentConvIndex--;
                displayConversation(currentConvIndex);
            }
        }

        function nextConversation() {
            if (currentConvIndex < currentConversations.length - 1) {
                currentConvIndex++;
                displayConversation(currentConvIndex);
            }
        }

        // Initialize on page load
        init();
    </script>
</body>
</html>
